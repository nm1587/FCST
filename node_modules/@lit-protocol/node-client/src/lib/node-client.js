"use strict";
var _NodeClient_isSuccessNodePromises;
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeClient = void 0;
const tslib_1 = require("tslib");
const access_control_conditions_1 = require("@lit-protocol/access-control-conditions");
const bls_sdk_1 = require("@lit-protocol/bls-sdk");
const constants_1 = require("@lit-protocol/constants");
const crypto_1 = require("@lit-protocol/crypto");
const encryption_1 = require("@lit-protocol/encryption");
const misc_1 = require("@lit-protocol/misc");
const uint8arrays_1 = require("@lit-protocol/uint8arrays");
const transactions_1 = require("@ethersproject/transactions");
const lit_siwe_1 = require("lit-siwe");
const utils_1 = require("ethers/lib/utils");
const lit_third_party_libs_1 = require("@lit-protocol/lit-third-party-libs");
const nacl_1 = require("@lit-protocol/nacl");
const misc_browser_1 = require("@lit-protocol/misc-browser");
const ethers_1 = require("ethers");
// import { checkAndSignAuthMessage } from '@lit-protocol/auth-browser';
/** ---------- Main Export Class ---------- */
class NodeClient {
    // ========== Constructor ==========
    constructor(args) {
        // ========== Scoped Class Helpers ==========
        /**
         *
         * Set bootstrapUrls to match the network litNetwork unless it's set to custom
         *
         * @returns { void }
         *
         */
        this.setCustomBootstrapUrls = () => {
            // -- validate
            if (this.config.litNetwork === 'custom')
                return;
            // -- execute
            const hasNetwork = this.config.litNetwork in constants_1.LIT_NETWORKS;
            if (!hasNetwork) {
                // network not found, report error
                (0, misc_1.throwError)({
                    message: 'the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS',
                    error: constants_1.LIT_ERROR.LIT_NODE_CLIENT_BAD_CONFIG_ERROR,
                });
                return;
            }
            this.config.bootstrapUrls = constants_1.LIT_NETWORKS[this.config.litNetwork];
        };
        /**
         *
         * Get either auth sig or session auth sig
         *
         */
        this.getAuthSigOrSessionAuthSig = ({ authSig, sessionSigs, url, }) => {
            // -- if there's session
            let sigToPassToNode = authSig;
            if (sessionSigs) {
                sigToPassToNode = sessionSigs[url];
                if (!sigToPassToNode) {
                    (0, misc_1.throwError)({
                        message: `You passed sessionSigs but we could not find session sig for node ${url}`,
                        error: constants_1.LIT_ERROR.INVALID_ARGUMENT_EXCEPTION,
                    });
                }
            }
            return sigToPassToNode;
        };
        /**
         *
         * Get the request body of the lit action
         *
         * @param { ExecuteJsProps } params
         *
         * @returns { JsonExecutionRequest }
         *
         */
        this.getLitActionRequestBody = (params) => {
            const reqBody = {
                authSig: params.authSig,
                jsParams: (0, misc_1.convertLitActionsParams)(params.jsParams),
                // singleNode: params.singleNode ?? false,
                targetNodeRange: params.targetNodeRange ?? 0,
            };
            if (params.code) {
                const _uint8Array = (0, uint8arrays_1.uint8arrayFromString)(params.code, 'utf8');
                const encodedJs = (0, uint8arrays_1.uint8arrayToString)(_uint8Array, 'base64');
                reqBody.code = encodedJs;
            }
            if (params.ipfsId) {
                reqBody.ipfsId = params.ipfsId;
            }
            return reqBody;
        };
        /**
         *
         * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
         *
         */
        this.getJWTParams = () => {
            const now = Date.now();
            const iat = Math.floor(now / 1000);
            const exp = iat + 12 * 60 * 60; // 12 hours in seconds
            return { iat, exp };
        };
        /**
         *
         * Parse the response string to JSON
         *
         * @param { string } responseString
         *
         * @returns { any } JSON object
         *
         */
        this.parseResponses = (responseString) => {
            let response;
            try {
                response = JSON.parse(responseString);
            }
            catch (e) {
                (0, misc_1.log)('Error parsing response as json.  Swallowing and returning as string.', responseString);
            }
            return response;
        };
        // ==================== SESSIONS ====================
        /**
         *
         * Try to get the session key in the local storage,
         * if not, generates one.
         * @param { string } supposedSessionKey
         * @return { }
         */
        this.getSessionKey = (supposedSessionKey) => {
            let sessionKey = supposedSessionKey ?? '';
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.SESSION_KEY;
            const storedSessionKeyOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            if (sessionKey === '') {
                // check if we already have a session key + signature for this chain
                // let storedSessionKey;
                let storedSessionKey;
                // -- (TRY) to get it in the local storage
                if (storedSessionKeyOrError.type === 'ERROR') {
                    console.warn(`Storage key "${storageKey}" is missing. Not a problem. Contiune...`);
                }
                else {
                    storedSessionKey = storedSessionKeyOrError.result;
                }
                // -- IF NOT: Generates one
                if (!storedSessionKey || storedSessionKey == '') {
                    sessionKey = (0, crypto_1.generateSessionKeyPair)();
                    // (TRY) to set to local storage
                    try {
                        localStorage.setItem(storageKey, JSON.stringify(sessionKey));
                    }
                    catch (e) {
                        console.warn(`Localstorage not available. Not a problem. Contiune...`);
                    }
                }
                else {
                    (0, misc_1.log)('storedSessionKeyOrError');
                    sessionKey = JSON.parse(storedSessionKeyOrError.result);
                }
            }
            return sessionKey;
        };
        /**
         *
         * Get session capabilities from user, it not, generates one
         * @param { Array<any> } capabilities
         * @param { Array<any> } resources
         * @return { Array<any> }
         */
        this.getSessionCapabilities = (capabilities, resources) => {
            if (!capabilities || capabilities.length == 0) {
                capabilities = resources.map((resource) => {
                    const { protocol, resourceId } = this.parseResource({ resource });
                    return `${protocol}Capability://*`;
                });
            }
            return capabilities;
        };
        /**
         *
         * Get expiration for session
         *
         */
        this.getExpiration = () => {
            return new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
        };
        /**
         *
         * Get the signature from local storage, if not, generates one
         *
         */
        this.getWalletSig = async ({ authNeededCallback, chain, capabilities, switchChain, expiration, sessionKeyUri, }) => {
            let walletSig;
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE;
            const storedWalletSigOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            // -- (TRY) to get it in the local storage
            if (storedWalletSigOrError.type === 'ERROR') {
                console.warn(`Storage key "${storageKey}" is missing. Not a problem. Contiune...`);
            }
            else {
                walletSig = storedWalletSigOrError.result;
            }
            // -- IF NOT: Generates one
            if (!storedWalletSigOrError.result || storedWalletSigOrError.result == '') {
                if (authNeededCallback) {
                    walletSig = await authNeededCallback({
                        chain,
                        resources: capabilities,
                        switchChain,
                        expiration,
                        uri: sessionKeyUri,
                    });
                }
                else {
                    if (!this.defaultAuthCallback) {
                        return (0, misc_1.throwError)({
                            message: 'No default auth callback provided',
                            error: constants_1.LIT_ERROR.PARAMS_MISSING_ERROR,
                        });
                    }
                    walletSig = await this.defaultAuthCallback({
                        chain,
                        resources: capabilities,
                        switchChain,
                        expiration,
                        uri: sessionKeyUri,
                    });
                }
            }
            else {
                try {
                    walletSig = JSON.parse(storedWalletSigOrError.result);
                }
                catch (e) {
                    console.warn('Error parsing walletSig', e);
                }
            }
            return walletSig;
        };
        /**
         *
         * Check if a session key needs to be resigned
         *
         */
        this.checkNeedToResignSessionKey = async ({ siweMessage, walletSignature, sessionKeyUri, resources, sessionCapabilities, }) => {
            let needToResign = false;
            try {
                // @ts-ignore
                await siweMessage.verify({ signature: walletSignature });
            }
            catch (e) {
                needToResign = true;
            }
            // make sure the sig is for the correct session key
            if (siweMessage.uri !== sessionKeyUri) {
                needToResign = true;
            }
            // make sure the sig has the session capabilities required to fulfill the resources requested
            for (let i = 0; i < resources.length; i++) {
                const resource = resources[i];
                const { protocol, resourceId } = this.parseResource({ resource });
                // check if we have blanket permissions or i